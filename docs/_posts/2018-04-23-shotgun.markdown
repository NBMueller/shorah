---
layout: default
modal-id: shotgun
date: 2014-07-18
title: Shotgun mode
img: shotgun.png
alt: Shotgun mode
# project-date: April 2014
# client: Start Bootstrap
# category: Web Development
description: I am interested in a region long enough that multiple reads are needed to cover it entirely. Coverage is variable, but it never drops too low.

---

### Introduction

This method is useful when the the region where the user wants to investigate the genetic diversity is long, _i.e._
one read is not sufficient to cover it. One of the first application of ShoRAH was to investigate the HIV
quasispecies observed on a region of the _pol_ gene around 1k bp long.

In this mode, reads are aligned to a sequence, then many overlapping windows are drawn on this alignment and reads
found in each of these windows are clustered together in order to remove sequencing errors. This analysis is shown here below.

### Preparation

We will be working with files in the `example_data` directory in the GitHub repository. Besides `shorah`, we will need:

- `bwa`,
- `samtools`,
- `wgsim`,

all available in Bioconda. Run the script `prepare.sh` and check that `aln_sorted.bam` has been created (run
`clean.sh` first if you previously run analyses in this folder). This is
a sorted BAM alignment of the 250 bp reads to the 1488 bp gag/pol sequence contained in `ref.fasta` and, together with
the reference, is the input for shorah.

### Analysis

Since we are using 250 bp long reads, our region of interest cannot be entirely covered by single reads. Rather,
we will draw multiple overlapping windows, each of them covering a region slightly shorter than 250 bp. Except at
the extreme points, each position will be covered by three such windows, and the final error correction will be
done with a majority rule.

We can find haplotypes on each of these region and correct error on reads with the following command.

    [user@host]$ shorah -b aln_sorted.bam -f ref.fasta shotgun
    ... some time later ...
    [user@host]$ head -6 ... | cut -c -80  # only prints 80 characters per line
    >hap_0|posterior=1 ave_reads=384.75
    TTAATCACAGTAAAAATAGGGGGACAGCTAATAGAAGCCCTATTAGACACAGGGGCAGATGATACAGTATTAGAAGAAAT
    >hap_1|posterior=1 ave_reads=313
    TTAGTCACAGTAAAAATAGGGGGACAGCCAATAGAAGCCCTATTAGACACAGGAGCAGATGATACAGTATTAGAAGAAAT
    >hap_2|posterior=0.0785 ave_reads=0.161
    TTAATCACAGTAAAAATAGGGGGACAGCTAATAGAAGCCCTATTAGACCCAGGGGCAGATGATACAGTATTAGAAGAAAT

### Interpretation

